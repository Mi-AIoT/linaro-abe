#!/bin/bash

####################################################
#Early (pre- exit trap installation) initialization#
####################################################
set -xue
set -o pipefail

#State that must be initialized before exit handler can be called
error=1
if test x"${BENCH_DEBUG}" = x || test x"${BENCH_DEBUG}" = xNone; then
  BENCH_DEBUG=
fi
#Ensure that we have no cruft left over from a previous run (we might be on a
#device with persistent filesystem, and it might have failed cleanup, or been
#cancelled)
rm -rf /tmp/bench-*

umask 077
#Exit handler expects maindir to be initialized
maindir="`mktemp -dt bench-XXXXXX`"
if test $? -ne 0; then
  echo "Unable to create maindir on target" >&2
  exit 1
fi

#exit handler expects data to exist, may as well create the others with it
mkdir "${maindir}"/{bin,bench,data,downloads} #Final mkdir
#End of state that must be initialized before exit handler can be called

#Called from exit trap
function ssh_rune {
  local preargs
  for x in "$@"; do
    shift
    if test x"$x" = 'x--'; then
      break
    fi
    if test x"${preargs:-}" = x; then
      preargs=("$x")
    else
      preargs=("${preargs[@]}" "$x")
    fi
  done

  #Output from this is unusable if interleaved with the -x output
  set +x
  echo -n "ssh -o ControlMaster=no -o ControlPath=/dev/null "
  if test x"${preargs:-}" != x; then
    echo -n "${preargs[@]} "
  fi
  echo '\'
  if test ${trusted} -eq 0; then
    echo "    -o UserKnownHostsFile=/dev/null ${ip_addr}.lab \\"
  else
    echo -n "    -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null root@${ip_addr}"
    if test $# -ne 0; then
      echo ' \'
    else
      echo
    fi
  fi

  echo "    $@"
  set -x
}

function exitfunc {
  #Attach significant logs
  #At least some of these logs are unlikely to be sensitive, but if any of them
  #change to include, say, sizes then they become sensitive. So we are paranoid.
  #trusted may not be initialized, but can only be 1 if we know we are trusted
  if test x"${trusted:-}" = x1; then
    if test -d "${maindir}"/bench/builds/*/*/*.git/; then #We expect this to evaluate to exactly one path, as we only build one thing
      pushd "${maindir}"/bench/builds/*/*/*.git/
      if test -f make-*.log; then
        'lava-test-run-attach' make-*.log text/plain #And we expect a maximum of one make-*.log
      else
        echo "Not attaching non-existent file ${PWD}/make-*.log" >&2
      fi
      if test -f build.log; then
        'lava-test-run-attach' build.log text/plain
        sed '0,/^size$/d' build.log | sed '1,2d' > "${maindir}"/data/sizes
        while read line; do
          name="`echo ${line} | awk '{print $6}'`"
          name="${name##*/}"
          'lava-test-case' "${name}[size][text]"  --result pass --units bytes --measurement `echo "${line}" | awk '{print $1}'`
          'lava-test-case' "${name}[size][data]"  --result pass --units bytes --measurement `echo "${line}" | awk '{print $2}'`
          'lava-test-case' "${name}[size][bss]"   --result pass --units bytes --measurement `echo "${line}" | awk '{print $3}'`
          'lava-test-case' "${name}[size][total]" --result pass --units bytes --measurement `echo "${line}" | awk '{print $4}'`
        done <"${maindir}/data/sizes"
      else
        echo "Not attaching non-existent file ${PWD}/build.log" >&2
      fi
      popd
    fi
    pushd "${maindir}"/data
    for x in {build,run}.std{out,err}; do
      if test -f "${x}"; then
        'lava-test-run-attach' "${x}" text/plain
      else
        echo "Not attaching non-existent file ${maindir}/data/${x}" >&2
      fi
    done
    popd
  fi
  if test ${error} -ne 0; then
    if test x"${BENCH_DEBUG}" != x; then
      echo "Trapped exit with error ${error}"
      echo "Sleeping for debug"
      if test x"${ip_addr:-}" = x; then
        ip_addr="`hostname -I | tr -d '[[:blank:]]'`"
      fi
      if test x"${trusted:-}" = x; then
        trusted=1 #pretending that we are trusted causes ssh_rune to give the
                  #most information to the user about flags they might need
      fi
      ssh_rune --
      sleep infinity&
      echo $! > "${maindir}/data/sleeper"
      wait $! || true #'|| true' -- don't terminate here if the sleeper is killed, want to do the cleanup
    fi
  fi
  rm -rf "${maindir}"
  exit ${error}
}

trap exitfunc EXIT


####################################################
#Late (after exit trap installation) initialization#
####################################################

function get_thing {
  local thing="${1}"
  pushd "${maindir}/downloads" > /dev/null

  #TODO: FOUL HACK: If there is a ci.linaro.org in the URL, it might be a
  #      Jenkins artifact that has not been published yet. Give it some time
  #      to get published before giving up.
  if echo "${thing}" | grep -q 'ci\.linaro\.org'; then
    local i
    for i in `seq 40 -1 1`; do
      wget -q --spider "${thing}" > /dev/null && break
      echo "${thing} not available" >&2
      echo "Will retry in 60 seconds" >&2
      echo "Will timeout in ${i} minutes" >&2
      test ${i} -gt 1 && sleep 60
    done
  fi

  if echo x"${thing}" | grep -q '^xhttp'; then
    #Password on CLI usually a bad thing, but for this case (builder is a
    #trusted machine restricted to trusted individuals) it is OK.
    wget -q${download_password:+ --user ${download_password%%:*} --password "${download_password#*:}"} "${thing}"
  else
    local server="${thing%%:*}"
    thing="${thing#*:}"
    (
      export ABE_REMOTE_SSH_OPTS="-o StrictHostKeyChecking=yes -o UserKnownHostsFile='${maindir}'/data/known_hosts${download_key:+ -i '${maindir}'/data/download_key}" &&
      . "${maindir}"/bench/host.conf &&
      topdir="${abe_path}" &&
      . "${topdir}"/lib/common.sh &&
      remote_download "${server}" "${thing}" .
    )
  fi
  if ! test -e "`basename ${thing}`"; then #TODO HACK set -e fails to apply to above incantations
    echo "Download of ${thing} failed" >&2
    exit 1
  fi
  popd > /dev/null
  echo "${maindir}/downloads/`basename ${thing}`"
}


#####################################
#Parse parameters/initialize globals#
#####################################

benchgccpath=
benchmark="${1}"
if test x"${benchmark}" = xNone; then
  echo "Must give benchmark" >&2
  exit 1
fi
shift
if test x"${1}" != xNone; then
  toolchain="${1}"
fi
shift
if test x"${1}" != xNone; then
  triple="${1}"
fi
shift
if test x"${1}" != xNone; then
  sysroot="${1}"
fi
shift
if test x"${1}" != xNone; then
  run_flags="${1}"
fi
shift
if test x"${1}" != xNone; then
  compiler_flags="${1}"
fi
shift
if test x"${1}" != xNone; then
  make_flags="${1}"
fi
shift
if test x"${1}" != xNone; then
  prebuilt="${1}"
fi
shift
if test x"${1}" = xNone; then
  trusted=0
elif test x"${1}" = xTrusted; then
  trusted=0
  for i in 1 2 3 4 5; do
    if ping -q -c 1 -t 1 lava.tcwglab; then
      trusted=1
      break
    fi
  done
  if test ${trusted} -eq 0; then
    echo "Trusted set in YAML but either:" >&2
    echo "lava.tcwglab is more than 1 hop away" >&2
    echo "lava.tcwglab could not be found in 5 pings" >&2
    exit 1
  fi
else
  echo "Bad value '${1}' for TRUST" >&2
  exit 1
fi
shift
if test "x${1}" != xNone; then
  download_password="${1}"
fi
shift
if test "x${1}" != xNone; then
  download_key="${1}"
  #* Storing this in a file is OK so long as the builder is a trusted machine
  #restricted to just trusted individuals.
  #* We observe that the translation from CLI->yaml->JSON substitutes
  #newlines for spaces in what we see here, so assume that spaces are not legal
  #characters in a private key and take advantage of that.
  #If this turns out not to be robust enough, alternative approaches include
  #inserting explicit newlines and decoding them here or (arguably) inserting a
  #newline every 64 characters and eliminating spaces.
  #Once jobs are defined in YAML rather than JSON this will likely look like a
  #multiline string here, making the 'sed' redundant.
  #* DANGER: the 4g thing is non-standard, correct for GNU sed (substitute all
  #matches from the 4th, see https://www.gnu.org/software/sed/manual/html_node/The-_0022s_0022-Command.html)
  echo "${download_key}" |
    sed 's/ -----END RSA PRIVATE KEY-----$//' |
    sed 's/ /\n/4g' > "${maindir}"/data/download_key
  echo '-----END RSA PRIVATE KEY-----' >> "${maindir}"/data/download_key
fi
shift
if test "x${1}" != xNone; then #DOWNLOAD_HOST
  echo "${1}" >> ${maindir}/data/known_hosts
fi
ip_addr=$(ifconfig `ip route get $gateway | cut -d ' ' -f3` | grep 'inet addr' |awk -F: '{split($2,a," "); print a[1] }')


#############################
#Set up filesystem and tools#
#############################

echo "Building (or getting) benchmark ${benchmark} in ${maindir}"
cd "${maindir}"/bench #Final directory change

export PATH="${maindir}"/bin:"${PATH}"

#Initialize git-new-workdir - sadly not just an apt-get call
#Needed before we run ${ABE_DIR}/configure
ln -f /usr/share/doc/git/contrib/workdir/git-new-workdir "${maindir}"/bin
chmod 755 "${maindir}"/bin/git-new-workdir

#Configure
#Must have run configure before first use of abe functions, may as well do it early
"${ABE_DIR}"/configure --with-fileserver=148.251.136.42 --with-remote-snapshots=/snapshots-ref


####################
#Set up credentials#
####################

#Set up known_hosts
#Need to be able to ssh to dev-private
echo 'dev-private.git.linaro.org ecdsa-sha2-nistp256 AAAAE2VjZHNhLXNoYTItbmlzdHAyNTYAAAAIbmlzdHAyNTYAAABBBOvq8E5HPzrBlxmckzsE3rz9LAx9c0faEfofALaO+UGC4HAst9fMaZcHaCqu+b8SVY/2VcBvMYMwO1ZPgOn0rXs=' >> "${maindir}/data/known_hosts"
#Permit scping of toolchains/built benchmarks from this machine
echo '148.251.136.42 ecdsa-sha2-nistp256 AAAAE2VjZHNhLXNoYTItbmlzdHAyNTYAAAAIbmlzdHAyNTYAAABBBKXzUdUnTOrX3sSzliFFAfQ+a5BxUUpvoWNHAVrLDW0Yodw2MWU/FdPZ6lvukOslYr3Jm+peit8kaXzlqX6mMxo=' >> "${maindir}/data/known_hosts"

#Export SSH config locations, for rest of this script and for subprocesses
export ABE_REMOTE_SSH_OPTS="-o BatchMode=yes -o StrictHostKeyChecking=yes -o UserKnownHostsFile=${maindir}/data/known_hosts"

if test ${trusted} -eq 0; then
  #Jobs runnning outside of the TCWG uinstance (or similar environment)
  #1) Live in an untrusted world
  #2) Rely on external forwarding of authentication tokens
  #3) Have no built-in knowledge of the systems they work with

  #Generate one-time key, so that external forwarding isn't need throughout run
  if ! ssh-keygen -P '' -f ${maindir}/data/id_rsa > /dev/null < /dev/null; then
    exit 1
  fi

  #Export SSH config locations, for rest of this script and for subprocesses
  export ABE_REMOTE_SSH_OPTS="${ABE_REMOTE_SSH_OPTS} -o IdentityFile=${maindir}/data/id_rsa"

  #Request agent just before we need it
  #This would be two keys in one agent if we wanted one for source, one for job
  echo "*** WAITING FOR AGENT: ${ip_addr}"
  ssh_rune -A -- "'ln -sf \$SSH_AUTH_SOCK ${maindir}/data/socket && while test -e ${maindir}/data/socket; do inotifywait -e delete ${maindir}/data; done'"
  while ! test -e "${maindir}"/data/socket; do
    inotifywait -e create "${maindir}"/data
  done
  export SSH_AUTH_SOCK="${maindir}"/data/socket
else
  export ABE_REMOTE_SSH_OPTS="${ABE_REMOTE_SSH_OPTS} -o IdentityFile=/home/lava-benchmark/.ssh/lava-benchmark"
fi

  #Give git access to the necessary ssh configuration
  cat > "${maindir}"/bin/git-ssh.sh <<EOF
#!/bin/bash
exec /usr/bin/ssh -o BatchMode=yes -o User=git ${ABE_REMOTE_SSH_OPTS} "\$@"
EOF
  chmod 700 "${maindir}"/bin/git-ssh.sh
  export GIT_SSH="${maindir}"/bin/git-ssh.sh


#######
#Build#
#######

#Install toolchain and build benchmark, or download prebuilt tarball
if test x"${prebuilt:-}" = x; then
  if test x"${toolchain:0:1}" = x/; then
    echo "Toolchain assumed to be path on builder"
    benchgccpath="${toolchain}"
  else
    tarball="`get_thing ${toolchain}`"
    tar xf "${tarball}" -C "${maindir}"/bin
    bindir="${maindir}/bin/`tar tf ${tarball} | sed -n 1p`/bin/" #head -n1 is faster, but breaks the pipe with error
    if test -n "${triple:-}"; then
      benchgccpath="${bindir}/${triple}-gcc"
      if ! test -x "${benchgccpath}"; then
        echo "${benchgccpath} does not exist or is not executable" 1>&2
        echo "Will try ${bindir}/gcc" 1>&2
        benchgccpath=
      fi
    fi
    if test -z "${benchgccpath}"; then
      benchgccpath="${bindir}/gcc"
    fi
    if ! test -x "${benchgccpath}"; then
      echo "${benchgccpath} does not exist or is not executable" 1>&2
      exit 1
    fi
    rm "${tarball}"
  fi

  if test x"${sysroot:-}" != x; then
    tarball="`get_thing ${sysroot}`"
    tar xf "${tarball}" -C "${maindir}"/bin
    sysroot="`ls -d ${maindir}/bin/`/`tar tf "${tarball}" | sed -n 1p`" #head -n1 is faster, but breaks the pipe with error
    rm "${tarball}"
  fi

  if test x"${sysroot:-}" != x; then
    make_flags="SYSROOT=\"${sysroot//\"/\\\"}\"${make_flags:+ ${make_flags//\"/\\\"}}"
  fi
  "${ABE_DIR}"/scripts/benchmark.sh \
    -s buildonly \
    ${compiler_flags:+-f "${compiler_flags}"} \
    ${make_flags:+-m "${make_flags}"} \
    -i "${benchgccpath}" \
    ${triple:+-x "${triple}"} \
    -b "${benchmark}" >"${maindir}"/data/build.stdout 2>"${maindir}"/data/build.stderr
  resultsdir="${benchmark}.git"
else
  benchtar="`get_thing ${prebuilt}`"
  resultsdir="`tar xf ${benchtar} | head -n1`"
fi


###################
#Configure targets#
###################
#Arrange access for each target

lava-network broadcast eth0 #Required with the lava-network, due to BZ1704
lava-network collect eth0
ip_addr="$(lava-network query `lava-group | grep '[[:blank:]]\+host$' | awk '{print $1}'` ipv4)"

target_names=()
for lava_name in `lava-group | grep -v '[[:blank:]]*host$' | awk '{print $1}'`; do
  target_ip="$(lava-network query ${lava_name} ipv4)"
  if test $? -ne 0; then echo "Failed to find IP for ${lava_name}"; exit 1; fi
  if test -z "${target_ip}"; then echo "Failed to find IP for ${lava_name}"; exit 1; fi

  #Check that target is accessible, add it to our known_hosts
  if ! ssh -o BatchMode=yes -o StrictHostKeyChecking=no ${ABE_REMOTE_SSH_OPTS} "${target_ip}" true; then
     echo "Could not access target ${target_ip} (${lava_name})" >&2
     exit 1
  fi

  if test ${trusted} -eq 0; then
    #add our one-time key to its authorized_keys
    if ! cat "${maindir}"/data/id_rsa.pub | ssh ${ABE_REMOTE_SSH_OPTS} "${target_ip}" "cat - >> ~/.ssh/authorized_keys"; then
      echo "Could not install one-time (public) key on target" >&2
      exit 1
    fi
  else #upload gather script so we can submit results to bundle stream
       #MUST be uploaded conditionally on ${trusted} --
       #target side will run gather.sh if it exists and thus dump data in results bundle
       #the gather script is allowed to be a symlink, so that we can write scripts that work for multiple benchmarks in a suite
    (
      . "${maindir}"/bench/host.conf &&
      topdir="${abe_path}" &&
      . "${topdir}"/lib/common.sh &&
      remote_upload "${target_ip}" "`readlink -e ${ABE_DIR}/config/bench/gather/${benchmark}.sh`" 'gather.sh'
    )
    if test $? -ne 0; then
      echo "Upload of ${ABE_DIR}/config/bench/gather/${benchmark}.sh to ${target_ip}:gather.sh failed" >&2
      exit 1
    fi
  fi

  #Generate configuration files for target
  lava-wait "config_${lava_name}"
  config="`cut -d = -f 2 /tmp/lava_multi_node_cache.txt`"
  if test $? -ne 0; then echo "Failed to find config file for ${lava_name}"; exit 1; fi
  sed "s/^ip=.*/ip=${target_ip}/" "${ABE_DIR}/config/bench/boards/${config}.conf" > "${ABE_DIR}/config/bench/boards/${lava_name}.conf"
  echo 'log_output=/dev/console' >> "${ABE_DIR}/config/bench/boards/${lava_name}.conf"
  if test $? -ne 0; then echo "Failed to generate config file for target ${lava_name}"; exit 1; fi

  if test -e "${ABE_DIR}/config/bench/boards/${config}.services"; then
    cp "${ABE_DIR}/config/bench/boards/${config}.services" "${ABE_DIR}/config/bench/boards/${lava_name}.services"
    if test $? -ne 0; then echo "Failed to generate services file for target ${lava_name}"; exit 1; fi
  fi

  if test "${#target_names[@]}" -eq 0; then
    target_names=("${lava_name}")
  else
    target_names=("${target_names[@]}" "${lava_name}")
  fi
done

#If we are relying on an external auth socket, we can delete it now
if test ${trusted} -eq 0; then
  rm "${maindir}/data/socket"
fi


#####
#Run#
#####

if test x"${BENCH_DEBUG:-}" = x; then
  politeness='-p'
else
  politeness=
fi

if test ${trusted} -eq 1; then
  sed -i 's/^safe_output=.*/safe_output=yes/' "${ABE_DIR}/config/${benchmark}.conf"
fi

#Note - env vars (in fact, whole command) in -e and -r line are evaluated on
#target. -r line is evaluated in context of the remote_exec_async command in
#runbench.sh.
#We do not run the gather script direct in the -r because it must be run in
#the contet of the LAVA test on the target side.
bash -x "${ABE_DIR}"/scripts/benchmark.sh \
  -s ${benchtar:-runonly} \
  ${politeness} \
  -e 'kill \$(cat \${HOME}/post-target)' \
  ${run_flags:+-a "${run_flags}"} \
  ${benchgccpath:+-i "${benchgccpath}"} \
  ${triple:+-x "${triple}"} \
  -b "${benchmark}" \
  -r 'function f {
        echo \${PWD} > \${HOME}/resultsdir || return \$?;
        sleep infinity&
        echo \$! > \${HOME}/post-run-finished || return \$?;
        kill \$(cat \${HOME}/post-run) || return \$?;
        wait \$!;
        if test \$? -ne 143; then return \$?; fi;
        test x\$(cat \${HOME}/gatherresult) != x || return \$?;
        return \$(cat \${HOME}/gatherresult);
      }; f' \
  "${target_names[@]}" >"${maindir}"/data/run.stdout 2>"${maindir}"/data/run.stderr

if test ${trusted} -eq 0; then
  #We are in an untrusted environment, so we have not directed that the target will send to bundle stream
  echo "*** RESULTS READY: ${ip_addr}"
  echo "To access data (which is in ${maindir}/bench/*-log):"
  ssh_rune
  echo "When you have the data, signal me to delete it and end job like this:"
  ssh_rune -- "'touch ${maindir}/data/resultsgone'"
  while ! test -e ${maindir}/data/resultsgone; do
    inotifywait -e create ${maindir}/data
  done
fi

error=0
exit
