#!/bin/bash

#Initialization - get us to defined exit func before we do anything else
set -xue
set -o pipefail

error=1
if test x"${BENCH_DEBUG}" = x || test x"${BENCH_DEBUG}" = xNone; then
  BENCH_DEBUG=
fi

function exitfunc {
  if test ${error} -ne 0; then
    if test x"${BENCH_DEBUG}" != x; then
      echo "Trapped exit with error ${error}"
      echo "Sleeping for debug"
      if test x"${ip_addr:-}" = x; then
        echo "ssh -o ControlMaster=no -o ControlPath=/dev/null `hostname -I | tr -d '[[:blank:]]'`.lab"
      else
        echo "ssh -o ControlMaster=no -o ControlPath=/dev/null ${ip_addr}.lab"
      fi
      sleep infinity
    fi
  fi
  if test x"${tmpdir:-}" != x; then
    if test -e "${tmpdir}"; then
      rm -rf "${tmpdir}"
    fi
  fi
  rm -rf ~/*
  exit ${error}
}

trap exitfunc EXIT

#Now we can exit cleanly, do remaining initialization

#Belt-and-braces - we do most work in maindir,
#which has 700 permissions, but this protects
#us against world-readable temporaries
umask 077

function get_thing {
  local thing="$1"
  pushd "${tmpdir}" > /dev/null
  if echo x"${thing}" | grep -q '^xhttp'; then
    wget -q "${thing}"
  else
    local server="${thing%%:*}"
    thing="${thing#*:}"
    (. "${maindir}"/host.conf && topdir="${abe_path}" && . "${topdir}"/lib/common.sh && remote_download "${server}" "${thing}" .)
    if ! test -e "`basename ${thing}`"; then #TODO HACK set -e fails to apply to above incantation
      echo "Download of ${server}:${thing} failed" >&2
      exit 1
    fi
  fi
  popd > /dev/null
  echo "${tmpdir}/`basename ${thing}`"
}

benchgccpath=
tmpdir="`mktemp -dt downloads-XXXXXXX`"

abe_branch="$1"
if x"${abe_branch}" = xNone; then
  echo "Must give abe branch" >&2
  exit 1
fi
benchmark="${2}"
if x"${benchmark}" = xNone; then
  echo "Must give benchmark" >&2
  exit 1
fi
toolchain="${3}"
if x"${toolchain}" = xNone; then
  echo "Must give toolchain" >&2
  exit 1
fi
if test x"$4" != xNone; then
  sysroot="${4}"
fi
if test x"$5" != xNone; then
  run_flags="$5"
fi
if test x"$6" != xNone; then
  compiler_flags="$6"
fi
if test x"$7" != xNone; then
  make_flags="$7"
fi
if test x"$8" != xNone; then
  prebuilt="$8"
fi
if test x"$9" = xNone; then
  trusted=0
elif test x"$9" = xTrusted; then
  trusted=0
  for i in 1 2 3 4 5; do
    if ping -q -c 1 -t 1 lava.tcwglab; then
      trusted=1
      break
    fi
  done
  if test ${trusted} -eq 0; then
    echo "Trusted set in YAML but either:" >&2
    echo "lava.tcwglab is more than 1 hop away" >&2
    echo "lava.tcwglab could not be found in 5 pings" >&2
    exit 1
  fi
else
  echo "Bad value '$9' for TRUST" >&2
  exit 1
fi

maindir="/${HOME}/bench"
echo "Building (or getting) benchmark ${benchmark} in ${maindir}"
mkdir "${maindir}" || exit 1
chmod 700 "${maindir}" || exit 1
cd "${maindir}"

#Initialize git-new-workdir - sadly not just an apt-get call
#Needed before we run ${ABE_DIR}/configure
ln /usr/share/doc/git/contrib/workdir/git-new-workdir /usr/local/bin
chmod 755 /usr/local/bin/git-new-workdir

#Configure
#Must have run configure before first use of abe functions, may as well do it early
"${ABE_DIR}"/configure --with-fileserver=148.251.136.42 --with-remote-snapshots=/snapshots-ref

#Generate config file for each target in multinode job
lava-network broadcast eth0 #Required with the lava-network, due to BZ1704
lava-network collect eth0
ip_addr="$(lava-network query `lava-group | grep '[[:blank:]]\+host$' | awk '{print $1}'` ipv4)"

#if test ${trusted} -eq 0; then
  #Jobs runnning outside of the TCWG uinstance (or similar environment)
  #1) Live in an untrusted world
  #2) Rely on external forwarding of authentication tokens
  #3) Have no built-in knowledge of the systems they work with

  #Generate one-time key, so that external forwarding isn't need throughout run
  if ! ssh-keygen -P '' -f ~/.ssh/id_rsa > /dev/null < /dev/null; then
    exit 1
  fi

  #Create directory for communication with other hosts
  mkdir ~/data || exit 1

  #Set up known_hosts
  #Need to be able to ssh to dev-private
  echo 'dev-private.git.linaro.org ecdsa-sha2-nistp256 AAAAE2VjZHNhLXNoYTItbmlzdHAyNTYAAAAIbmlzdHAyNTYAAABBBOvq8E5HPzrBlxmckzsE3rz9LAx9c0faEfofALaO+UGC4HAst9fMaZcHaCqu+b8SVY/2VcBvMYMwO1ZPgOn0rXs=' >> ~/.ssh/known_hosts
  #Permit scping of toolchains/built benchmarks from this machine
  echo '148.251.136.42 ecdsa-sha2-nistp256 AAAAE2VjZHNhLXNoYTItbmlzdHAyNTYAAAAIbmlzdHAyNTYAAABBBKXzUdUnTOrX3sSzliFFAfQ+a5BxUUpvoWNHAVrLDW0Yodw2MWU/FdPZ6lvukOslYr3Jm+peit8kaXzlqX6mMxo=' >> ~/.ssh/known_hosts

  #Request agent just before we need it
  #This would be two keys in one agent if we wanted one for source, one for job
  echo "*** WAITING FOR AGENT: ${ip_addr}"
  echo "ssh -o ControlMaster=no -o ControlPath=/dev/null -A root@${ip_addr}.lab 'ln -sf \$SSH_AUTH_SOCK /root/data/socket && while test -e /root/data/socket; do inotifywait -e delete /root/data; done'"
  while ! test -e ~/data/socket; do
    inotifywait -e create ~/data
  done
  export SSH_AUTH_SOCK=~/data/socket
#fi

target_names=()
for lava_name in `lava-group | grep -v '[[:blank:]]*host$' | awk '{print $1}'`; do
  target_ip="$(lava-network query ${lava_name} ipv4)"
  if test $? -ne 0; then echo "Failed to find IP for ${lava_name}"; exit 1; fi
  if test -z "${target_ip}"; then echo "Failed to find IP for ${lava_name}"; exit 1; fi

  #Check that target is accessible, add it to our known_hosts
  if ! ssh -o StrictHostKeyChecking=no "${target_ip}" true; then
     echo "Could not access target ${target_ip} (${lava_name})" >&2
     exit 1
  fi

  #if test ${trusted} -eq 0; then
    #add our one-time key to its authorized_keys
    if ! cat ~/.ssh/id_rsa.pub | ssh "${target_ip}" "cat - >> ~/.ssh/authorized_keys"; then
      echo "Could not install one-time (public) key on target" >&2
      exit 1
    fi
  #else #upload gather script so we can submit results to bundle stream
  if test ${trusted} -ne 0; then
       #MUST be uploaded conditionally on ${trusted} --
       #target side will run gather.sh if it exists and thus dump data in results bundle
    (. "${maindir}"/host.conf && topdir="${abe_path}" && . "${topdir}"/lib/common.sh && remote_upload "${target_ip}" "${ABE_DIR}/config/bench/gather/${benchmark}.sh" 'gather.sh')
    if test $? -ne 0; then
      echo "Upload of ${ABE_DIR}/config/bench/gather/${benchmark}.sh to ${target_ip}:gather.sh failed" >&2
      exit 1
    fi
  fi

  #Generate configuration files for target
  lava-wait "config_${lava_name}"
  config="`cut -d = -f 2 /tmp/lava_multi_node_cache.txt`"
  if test $? -ne 0; then echo "Failed to find config file for ${lava_name}"; exit 1; fi
  sed "s/^ip=.*/ip=${target_ip}/" "${ABE_DIR}/config/bench/boards/${config}.conf" > "${ABE_DIR}/config/bench/boards/${lava_name}.conf"
  if test $? -ne 0; then echo "Failed to generate config file for target ${lava_name}"; exit 1; fi

  if test -e "${ABE_DIR}/config/bench/boards/${config}.services"; then
    cp "${ABE_DIR}/config/bench/boards/${config}.services" "${ABE_DIR}/config/bench/boards/${lava_name}.services"
    if test $? -ne 0; then echo "Failed to generate services file for target ${lava_name}"; exit 1; fi
  fi

  if test "${#target_names[@]}" -eq 0; then
    target_names=("${lava_name}")
  else
    target_names=("${target_names[@]}" "${lava_name}")
  fi
done

#Install toolchain and build benchmark, or download prebuilt tarball
if test x"${prebuilt:-}" = x; then
  mkdir bin
  if test x"${toolchain:0:1}" = x/; then
    echo "Toolchain assumed to be path on builder"
    benchgccpath="${toolchain}"
  else
    tarball="`get_thing ${toolchain}`"
    tar xf "${tarball}" -C bin
    benchgccpath="`ls ${PWD}/bin/*/bin/*gcc`"
    rm "${tarball}"
  fi

  if test "`echo ${benchgccpath} | wc -w`" -ne 1; then
    echo "Should be exactly one GCC path" 1>&2
    echo "Got: ${benchgccpath}" 1>&2
    exit 1
  fi
  if test x"${benchgccpath}" != x; then
    if ! test -x "${benchgccpath}"; then
      echo "GCC binary '${benchgccpath}' does not exist or is not executable" 1>&2
      exit 1
    fi
  fi

  if test x"${sysroot:-}" != x; then
    tarball="`get_thing ${sysroot}`"
    tar xf "${tarball}" -C bin
    sysroot="`ls -d ${PWD}/bin/`/`tar tf "${tarball}" | sed -n 1p`" #head -n1 is faster, but breaks the pipe with error
    rm "${tarball}"
  fi

  if test x"${sysroot:-}" != x; then
    compiler_flags="${sysroot:+--sysroot ${sysroot//\"/\\\"} }${compiler_flags:+${compiler_flags//\"/\\\"}}"
  fi
  "${ABE_DIR}"/scripts/benchmark.sh \
    -s buildonly \
    ${compiler_flags:+-f "${compiler_flags//\"/\\\"}"} \
    ${make_flags:+-m "${make_flags}"} \
    -i "${benchgccpath}" \
    -b "${benchmark}" \
    "${target_names[@]}"
  resultsdir="${benchmark}.git"
else
  benchtar="`get_thing ${prebuilt}`"
  resultsdir="`tar xf ${benchtar} | head -n1`"
  benchgccpath="${toolchain}"
fi

#If we are relying on an external auth socket, we can delete it now
#if test ${trusted} -eq 0; then
  rm "${HOME}/data/socket"
#fi

#Run
if test x"${BENCH_DEBUG:-}" = x; then
  politeness='-p'
else
  politeness=
fi

#Note - env vars (in fact, whole command) in -e and -r line are evaluated on
#target. -r line is evaluated in context of the remote_exec_async command in
#runbench.sh.
#We do not run the gather script direct in the -r because it must be run in
#the contet of the LAVA test on the target side.
"${ABE_DIR}"/scripts/benchmark.sh \
  -s ${benchtar:-runonly} \
  ${politeness} \
  -e 'kill \$(cat \${HOME}/post-target)' \
  ${run_flags:+-a "${run_flags}"} \
  ${benchgccpath:+-i "${benchgccpath}"} \
  -b "${benchmark}" \
  -r 'function f {
        echo \${PWD} > \${HOME}/resultsdir || return \$?;
        sleep infinity&
        echo \$! > \${HOME}/post-run-finished || return \$?;
        kill \$(cat \${HOME}/post-run) || return \$?;
        wait \$!;
        if test \$? -ne 143; then return \$?; fi;
        test x\$(cat \${HOME}/gatherresult) != x || return \$?;
        return \$(cat \${HOME}/gatherresult);
      }; f' \
  "${target_names[@]}"

if test ${trusted} -eq 0; then
  #We are in an untrusted environment, so we have not directed that the target will send to bundle stream
  echo "*** RESULTS READY: ${ip_addr}"
  echo "ssh -o ControlMaster=no -o ControlPath=/dev/null root@${ip_addr}.lab"
  echo "ssh -o ControlMaster=no -o ControlPath=/dev/null root@${ip_addr}.lab 'touch ~/data/resultsgone'"
  while ! test -e ~/data/resultsgone; do
    inotifywait -e create ~/data
  done
fi

error=0
exit
