#!/bin/bash
set -uex
set -o pipefail

#LAVA cannot exit until all the processes that this shell started are killed
#This also kills sleeps on the target that were started by the host (which is
#what we want).
trap 'kill `pidof sleep`' EXIT

#Pidfile creators are responsible for:
#1: Creating a directory named <pidfile>-sync _after_ pidfile is written
#2: Ensuring that pidfile and <pidfile>-sync are cleaned up on process exit
#   Deleting <pidfile>-sync first.
#This avoids the following races:
#1: pidfile was incompletely written
#2: pid exited and was replaced with another process
#   EXCEPT when this happens between the test and the kill delivery
#   Given that we have full control of host and target, that targets are
#   rebooted between jobs and that virtually all of our pidfiles point at
#   processes that will only exit in pathological conditions, we can live with
#   it.
#   TODO: Use files rather than infinite sleeps as our synchronization
#   primitive. We can do this by busy-waiting on file creation/deletion, or
#   by using inotify-tools to (presumably) work in some lower-impact fashion.
#   Not busy-waiting would be preferable, to minimize target activity.
#2 is hopefully not needed when the process being waited on is our own child -
#these scripts in general are written on the understanding that child pids are
#not released until waited on.
function safe_kill {
  test -n "${1:-}" || { echo "No pidfile" >&2; exit 1; }
  test -d "${1}-sync"
  cat "$1" | xargs kill ${2:-}
}

function init_sleeper {
  test -n "${1:-}" || { echo "No pidfile" >&2; exit 1; }
  local pidfile=$1
  #The sleep below will continue to run after the subshell is killed, but will
  #get caught in our exit trap. The command could be anything to stop the
  #subshell from exiting, sleep is just convenient for this purpose.
  (
    function f {
      rmdir "${pidfile}-sync"
      rm "${pidfile}"
    }
    trap f EXIT
    sleep "${2:-infinity}"
  )&
  echo $! > "${pidfile}"
  mkdir "${pidfile}-sync"
}

function wait_sleeper {
  test -n "${1:-}" || { echo "No pidfile" >&2; exit 1; }
  test -d "${1}-sync"
  wait "`cat $1`"
}

#Exit as cleanly as possible, but with an error
function quit {
  echo "Received SIGTERM, will exit with error" >&2
  trap 'exit 143' EXIT
  for x in /root/{sync-host,post-target,post-run}; do
    safe_kill "${x}"
  done
  for x in /root/{benchproc,post-run-finished}; do
    safe_kill "${x}"
  done
}
trap quit TERM

#Make sure that host is always signalled when target gives up
function err {
  quit
  trap 'exit 1' EXIT
}
trap err ERR

#All sleepers must be initialized before the below timeout on hostside bringup
#This way, we know that the 'kill target on exit' code on the host side will
#actually kill the target.
init_sleeper /root/post-run
init_sleeper /root/post-target

#Wait 1 hour for all targets to be ready. Even our slowest targets boot in less
#than 1 hour.
init_sleeper /root/sync-host 3600

#Time bomb - terminate target when sync-host expires
wait_sleeper /root/sync-host &

lava-network broadcast eth0
lava-send "config_`lava-self`" "config=${1}"
lava-wait-all "`lava-self`"_init host

#Host now capable of killing this target on exit, we can kill the time bomb
safe_kill /root/sync-host

wait_sleeper /root/post-run && false
if test $? -eq 143; then true; else false; fi

#We must run the gather script here for lava commands (lava-test-run-attach,
#lava-test-case) to work correctly.
if test -e "${HOME}"/gather.sh; then
  if ! test -e "${HOME}"/resultsdir; then
    echo "No resultsdir given" >&2
    exit 1
  fi
  "${HOME}"/gather.sh `cat "${HOME}"/resultsdir`
  echo $? > "${HOME}"/gatherresult
else #Act as though we succeeded if there was nothing to do
  echo 0 > "${HOME}"/gatherresult
fi
#post-run-finished must be completely written, as it is written before
#post-run (waited on above) is killed. We use safe_kill to ensure that
#it has not been replaced with another process with identical pid.
safe_kill /root/post-run-finished

wait_sleeper /root/post-target && false
if test $? -eq 143; then true; else false; fi

exit 0
